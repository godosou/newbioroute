//----------------------------------------------------------------
// File: patRandomWalk.cc
// Author: Michel Bierlaire
// Creation: Tue May 19 17:12:26 2009
//----------------------------------------------------------------

#include "patDisplay.h"
#include "patRandomWalk.h"
#include "patString.h"
#include "patErrMiscError.h"
#include "patNetwork.h"
#include "patPower.h"
#include "patDiscreteDistribution.h"
#include "patParameters.h"

patRandomWalk::patRandomWalk() :
  patPathGenerationAlgo(patString("Random walk")),
  kumaA(1.0),
  kumaB(1.0),
  randomNumbersGenerator(patParameters::the()->getgevSeed()) {
  
}

void patRandomWalk::generateNextPath(patNetwork* theNetwork, patOd theOd, patError*& err) {
  patPath thePath ;
  thePath.name = patString("Generated by random walk") ;
  thePath.od = theOd ;
  unsigned long currentNode = theOd.orig ;
  double logProba = 0.0 ;
  
  thePath.listOfNodes.push_back(theOd.orig) ;
  while (currentNode != theOd.dest) {
    pair<unsigned long,double> result = 
      getNextNodeInRandomWalk(theNetwork,
			      currentNode,
			      theOd.dest,
			      err) ;
    if (err != NULL) {
      WARNING(err->describe()) ;
      return  ;
    }
    thePath.listOfNodes.push_back(result.first) ;
    logProba += log(result.second) ;
    currentNode = result.first ;
  }

  map<patPath,pair<double,unsigned long> >::iterator found ;
  found = listOfPaths.find(thePath) ;
  if (found == listOfPaths.end()) {
    listOfPaths[thePath] = pair<double,unsigned long>(logProba,1) ;
  } 
  else {
    if (found->second.first != logProba) {
      stringstream str ;
      str << "Path generated with log-proba " << logProba << " and previously generated with log-proba " << found->second.first ;
      err = new patErrMiscError(str.str()) ;
      return ;
    }
    ++found->second.second ;
  }
  
}



pair<unsigned long,double> patRandomWalk::getNextNodeInRandomWalk(patNetwork* theNetwork, 
							      unsigned long currentNode, 
							      unsigned long dest, 
							      patError*& err) {


  if (currentNode == dest) {
    return pair<unsigned long,double>(patBadId,0.0) ;
  }
  
  patNode* theCurrentNode = theNetwork->getNodeFromUserId(currentNode) ;
  patIterator<unsigned long>* outgoingNodes = theCurrentNode->getSuccessors() ;

  patOd theOd(currentNode,dest) ;


  // The shortest path cost

  double theShortest = theNetwork->getShortestPathCost(theOd,err) ;
  if (err != NULL) {
    WARNING(err->describe()) ;
    return pair<unsigned long,double>();
  }
  
  // Loop on the outgoing edges, and compute the cost of each shortest paths.

  vector<double> proba ;
  vector<unsigned long> theNodes ;

  double total(0.0) ;

  for (outgoingNodes->first() ;
       !outgoingNodes->isDone() ;
       outgoingNodes->next()) {
    unsigned long theNextNode = outgoingNodes->currentItem() ;
    patArc* theArc = theNetwork->getArcFromNodesUserId(theCurrentNode->getUserId(),theNextNode) ;
    if (theArc == NULL) {
      stringstream str ;
      str << "Could not find the arc from node " << theCurrentNode->getUserId() << " to node " << theNextNode ;
      err = new patErrMiscError(str.str()) ;
      WARNING(err->describe()) ;
      return pair<unsigned long,double>() ;
    }


    theOd.orig = theNextNode ;
    double spCost = theNetwork->getShortestPathCost(theOd,err) ;
    if (err != NULL) {
      WARNING(err->describe()) ;
      return pair<unsigned long,double>();
    }
    
    double diff = double(theShortest) - double(spCost) - double(theArc->generalizedCost) ;
    if (diff > patSQRT_EPSILON) {
      stringstream str ;
      str << "Ratio should be lesser or equal to 1, and is " << double(theShortest) << " / (" <<  double(spCost) << " + " <<  double(theArc->generalizedCost) << ")" ;
      err = new patErrMiscError(str.str()) ;
      WARNING(err->describe()) ;
      return pair<unsigned long,double>();
    }
    double theRatio = double(theShortest) / double(spCost + theArc->generalizedCost) ;

    double kuma = 1.0 - patPower(1.0 - patPower(theRatio,kumaA) , kumaB) ;
    if (!finite(kuma)) {
      kuma = 0.0 ;
    }
    
    total += kuma ;
    proba.push_back(kuma) ;
    theNodes.push_back(theNextNode) ;
  }
  
  for (vector<double>::iterator i = proba.begin() ;
       i != proba.end() ;
       ++i) {
    *i /= total ;
  }


  unsigned long selectId = 
    patDiscreteDistribution(&proba,
			    &randomNumbersGenerator)() ;
  
  //  DEBUG_MESSAGE("SELECT NODE " << theNodes[selectId] << " with proba " << proba[selectId]) ;


  return pair<unsigned long,double>(theNodes[selectId],proba[selectId]) ;
  
}

void patRandomWalk::setKumaParameters(double a, double b) {
  kumaA = a ;
  kumaB = b ;
}

patString patRandomWalk::getReport() {
  
}
